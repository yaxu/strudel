---
title: Erste Effekte
layout: ../../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../../docs/MiniRepl';
import QA from '@components/QA';

# Erste Effekte

import Box from '@components/Box.astro';

## Ein paar grundlegende Effekte

**low-pass filter**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("sawtooth").lpf(800)`}
/>

<Box>

lpf = **l**ow **p**ass **f**ilter

- √Ñndere `lpf` in 200. H√∂rst du, wie der Bass dumpfer klingt? Es klingt so, als w√ºrde die Musik hinter einer geschlossenen T√ºr spielen üö™
- Lass uns nun die T√ºr √∂ffnen: √Ñndere `lpf` in 5000. Der Klang wird dadurch viel heller und sch√§rfer ‚ú®ü™©

</Box>

**filter automatisieren**

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("sawtooth").lpf("200 1000")`}
/>

<Box>

- F√ºg noch mehr `lpf` Werte hinzu
- Das Pattern in `lpf` √§ndert nicht den Rhythmus der Basslinie

Sp√§ter sehen wir, wie man mit Wellenformen Dinge automatisieren kann.

</Box>

**vowel = Vokal**

<MiniRepl
  client:visible
  tune={`note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>/2")
.sound("sawtooth").vowel("<a e i o>/2")`}
/>

**gain = Verst√§rkung**

<MiniRepl
  client:visible
  tune={`stack(
  sound("hh*8").gain("[.25 1]*2"),
  sound("bd*2,~ sd:1")
) `}
  punchcard
/>

<Box>

Bei Rhythmen ist die Dynamik (= Ver√§nderungen der Lautst√§rke) sehr wichtig.

- Entferne `.gain(...)` und achte darauf, wie es viel flacher klingt.
- Mach es r√ºckg√§ngig (strg+z dann strg+enter)

</Box>

**stacks in stacks**

Lass uns die obigen Beispiele kombinieren:

<MiniRepl
  client:visible
  tune={`stack(
  stack(
    sound("hh*8").gain("[.25 1]*2"),
    sound("bd*2,~ sd:1")
  ),
  note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
  .sound("sawtooth").lpf("200 1000"),
  note("<[c3,g3,e4] [bb2,f3,d4] [a2,f3,c4] [bb2,g3,eb4]>/2")
  .sound("sawtooth").vowel("<a e i o>/2")
) `}
/>

<Box>

Versuche die einzelnen Teile innerhalb von `stack` zu erkennen. Schau dir an wie die Kommas gesetzt sind.

Die 3 Teile (Drums, Bass, Akkorde) sind genau wie vorher, nur in einem `stack`, getrennt durch Kommas.

</Box>

**Den Sound formen mit ADSR-H√ºllkurve**

<MiniRepl
  client:visible
  tune={`note("<c3 bb2 f3 eb3>")
.sound("sawtooth").lpf(600)
.attack(.1)
.decay(.1)
.sustain(.25)
.release(.2)`}
/>

<Box>

Versuche herauszufinden, was die Zahlen machen. Probier folgendes:

- attack: `.5` vs `0`
- decay: `.5` vs `0`
- sustain: `1` vs `.25` vs `0`
- release: `0` vs `.5` vs `1`

Kannst du erraten, was die einzelnen Werte machen?

</Box>

<QA q="L√∂sung anzeigen" client:visible>

- attack (anschlagen): Zeit des Aufbaus
- decay (zerfallen): Zeit des Abfalls
- sustain (erhalten): Lautst√§rke nach Abfall
- release (loslassen): Zeit des Abfalls nach dem Ende

![ADSR](https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/ADSR_parameter.svg/1920px-ADSR_parameter.svg.png)

</QA>

**adsr-Kurznotation**

<MiniRepl
  client:visible
  tune={`note("<c3 bb2 f3 eb3>")
.sound("sawtooth").lpf(600)
.adsr(".1:.1:.5:.2")
`}
/>

**delay = Verz√∂gerung**

<MiniRepl
  client:visible
  tune={`stack(
  note("~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]")
  .sound("gm_electric_guitar_muted"),
  sound("<bd rim>").bank("RolandTR707")
).delay(".5")`}
/>

<Box>

Probier verschiedene `delay` Werte zwischen 0 und 1. √úbrigens: `.5` ist kurz f√ºr `0.5`.

Was passiert, wenn du `.delay(".8:.125")` schreibst? Kannst du erraten, was die zweite Zahl macht?

Was passiert, wenn du `.delay(".8:.06:.8")` schreibst? Kannst du erraten, was die dritte Zahl macht?

</Box>

<QA q="L√∂sung anzeigen" client:visible>

`delay("a:b:c")`:

- a: Lautst√§rke des Delays
- b: Verz√∂gerungszeit
- c: Feedback (je kleiner, desto schneller verschwindet das Delay)

</QA>

**room aka reverb = Hall**

<MiniRepl
  client:visible
  tune={`n("<4 [3@3 4] [<2 0> ~@16] ~>/2")
.scale("D4:minor").sound("gm_accordion:2")
.room(2)`}
/>

<Box>

Spiel mit verschiedenen Werten.

F√ºg auch ein Delay hinzu!

</Box>

**kleiner Dub-Tune**

<MiniRepl
  client:visible
  tune={`stack(
  note("~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]")
  .sound("gm_electric_guitar_muted").delay(.5),
  sound("<bd rim>").bank("RolandTR707").delay(.5),
  n("<4 [3@3 4] [<2 0> ~@16] ~>/2")
  .scale("D4:minor").sound("gm_accordion:2")
  .room(2).gain(.5)
)`}
/>

F√ºr echten Dub fehlt noch der Bass:

<MiniRepl
  client:visible
  tune={`stack(
  note("~ [<[d3,a3,f4]!2 [d3,bb3,g4]!2> ~]")
  .sound("gm_electric_guitar_muted").delay(.5),
  sound("<bd rim>").bank("RolandTR707").delay(.5),
  n("<4 [3@3 4] [<2 0> ~@16] ~>/2")
  .scale("D4:minor").sound("gm_accordion:2")
  .room(2).gain(.4),
  n("<0 [~ 0] 4 [3 2] [0 ~] [0 ~] <0 2> ~>*2")
  .scale("D2:minor")
  .sound("sawtooth,triangle").lpf(800)
)`}
/>

<Box>

F√ºg `.hush()` ans Ende eines Patterns im stack...

</Box>

**pan = Panorama**

<MiniRepl
  client:visible
  tune={`sound("numbers:1 numbers:2 numbers:3 numbers:4")
.pan("0 0.3 .6 1")
.slow(2)`}
/>

**speed = Geschwindigkeit**

<MiniRepl client:visible tune={`sound("bd rim").speed("<1 2 -1 -2>").room(.2)`} />

**fast and slow = schnell und langsam**

Mit `fast` und `slow` kann man das Tempo eines Patterns au√üerhalb der Mini-Notation √§ndern:

<MiniRepl client:visible tune={`sound("bd*2,~ rim").slow(2)`} />

<Box>

√Ñndere den `slow`-Wert. Ersetze `slow` durch `fast`.

Was passiert, wenn du den Wert automatisierst? z.b. `.fast("<1 [2 4]>")` ?

</Box>

√úbrigens, innerhalb der Mini-Notation: `fast` ist `*` und `slow` ist `/`.

<MiniRepl client:visible tune={`sound("[bd*2,~ rim]*<1 [2 4]>")`} />

## Automation mit Signalen

Anstatt Werte schrittweise zu automatisieren, k√∂nnen wir auch sogenannte Signale benutzen:

<MiniRepl client:visible tune={`sound("hh*16").gain(sine)`} punchcard punchcardLabels={false} />

<Box>

Die grundlegenden Wellenformen sind `sine`, `saw`, `square`, `tri` üåä

Probiere auch die zuf√§lligen Signale `rand` und `perlin`!

Der `gain`-Wert (Verst√§rkung) wird in der Visualisierung als Transparenz dargestellt.

</Box>

**Bereich √§ndern mit `range`**

Signale bewegen sich standardm√§√üig zwischen 0 und 1. Wir k√∂nnen das mit `range` √§ndern:

<MiniRepl client:visible tune={`sound("hh*8").lpf(saw.range(500, 2000))`} />

`range` ist n√ºtzlich wenn wir Funktionen mit einem anderen Wertebereich als 0 und 1 automatisieren wollen (z.b. `lpf`)

<Box>

Was passiert wenn du die beiden Werte vertauschst?

</Box>

Wir k√∂nnen die Geschwindigkeit der Automation mit slow / fast √§ndern:

<MiniRepl
  client:visible
  tune={`note("<[c2 c3]*4 [bb1 bb2]*4 [f2 f3]*4 [eb2 eb3]*4>/2")
.sound("sawtooth")
.lpf(sine.range(100, 2000).slow(8))`}
/>

<Box>

Die ganze Automation braucht nun 8 cycle bis sie sich wiederholt.

</Box>

## R√ºckblick

| Name  | Beispiel                                                                                |
| ----- | --------------------------------------------------------------------------------------- |
| lpf   | <MiniRepl client:visible tune={`note("c2 c3").s("sawtooth").lpf("<400 2000>")`} />      |
| vowel | <MiniRepl client:visible tune={`note("c3 eb3 g3").s("sawtooth").vowel("<a e i o>")`} /> |
| gain  | <MiniRepl client:visible tune={`s("hh*8").gain("[.25 1]*2")`} />                        |
| delay | <MiniRepl client:visible tune={`s("bd rim").delay(.5)`} />                              |
| room  | <MiniRepl client:visible tune={`s("bd rim").room(.5)`} />                               |
| pan   | <MiniRepl client:visible tune={`s("bd rim").pan("0 1")`} />                             |
| speed | <MiniRepl client:visible tune={`s("bd rim").speed("<1 2 -1 -2>")`} />                   |
| range | <MiniRepl client:visible tune={`s("hh*16").lpf(saw.range(200,4000))`} />                |

Lass uns nun die f√ºr Tidal typischen [Pattern-Effekte anschauen](/de/workshop/pattern-effects).
